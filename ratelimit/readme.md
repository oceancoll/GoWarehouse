- Counter计数   counterWindow.go  
&nbsp;通过key与tick构成实际的key，使用redis计数，每次调用该key的value+1，当value大于实际的limit时，则被限  
&nbsp;  缺点: 限流不够平滑。  
  &nbsp;&nbsp;当一分钟限流5次时，前30s没有调用，后30s有5次调用。下一分钟前30s有5次调用，则对于30s-90s的过程中，有10次调用，不满足1分钟内5次调用的限制
  
- 滑动窗口 slidingWindow.go  
  &nbsp;将一个限流区间划分为多个更小的区间，每次在小区间计数时，向前取一个大区间范围的小区间数，求和。当总和大于limit限制时，则被限流
  
- 令牌桶 buckettoken.go  
  &nbsp;一个桶的最多能存储的令牌个数为b，每秒向桶中插入a个令牌。每个请求只有从桶中获得令牌才可执行。取不到令牌就会被限流。  
  通过懒加载的方式，记录上次访问的时间和当前剩余令牌个数，每次请求时，才计算距上次访问时间，差值内需要补充多少个令牌。已经是否满足限流条件


|        | 计数器 | 漏斗桶  | 令牌桶  |  
|  ----  | ----  | ----  | ----  |
| 具体实现  | 使用全局计数 | 使用队列+处理器 | 使用漏斗算法 |
| 适用场景  | API配额/限流  适合限流后丢弃处理 | 流量整形  适合限流后阻塞排队 | 大多数场景均可 |